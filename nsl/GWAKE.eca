require import AllCore FMap FSet.

type id, msg, istate, rstate, key, pskey.

op dkey: key distr.
op dpskey: pskey distr.

(* Represents the role of an instance in the protocol *)
type role = [
  Initiator
| Responder
].

type trace = (id * msg) * msg * msg.

(* Represents an instance state in the protocol *)
type instance_state = [
  RStarted of id
| IPending of istate & (id * msg)
| RPending of rstate & (id * msg) & msg
| Accepted of trace & key
| Observed of trace & key
| Aborted
].

(* Return the trace from an accepted state *)
op get_trace s : trace option =
with s = Accepted t _   => Some t
with s = Observed t _   => Some t
with s = IPending _ _   => None
with s = RPending _ _ _ => None
with s = RStarted _     => None
with s = Aborted        => None.

(* Decide if an instance has been revelaed *)
op is_observed s : bool =
with s = Observed _ _   => true
with s = Accepted _ _   => false
with s = IPending _ _   => false
with s = RPending _ _ _ => false
with s = RStarted _     => false
with s = Aborted        => false.

(* Get all trace-sharing instances *)
op get_ts_instances t (fmap : (int, id * role * instance_state) fmap) =
  fdom (filter (fun x (val: id * role * instance_state) => (get_trace val.`3) = Some t) fmap).

(* Get all partners of the given instance *)
op get_partners ai t r (fmap: (int, id * role * instance_state) fmap) =
fdom (
  filter
  (fun bj (val: id * role * instance_state) =>
        bj <> ai            (* We cannot be our own partner *)
    /\ get_trace val.`3 = t (* Partners share the same trace *)
    /\ val.`2 <> r          (* Partners must have opposite roles *)
    /\ t <> None            (* We must be accepted *)
  )
  fmap
).

op get_observed_partners ai  (fmap : (int, id * role * instance_state) fmap) =
  let (i, r, s) = oget fmap.[ai] in
  filter
    (fun bj => oapp (fun z => is_observed z) false (Some (oget fmap.[bj]).`3))
    (get_partners ai (get_trace s) r fmap).

(********************************************************************************)
(* Defining AKE schemes *)

module type AKE_Scheme = {
  proc msg1(a: id, b: id, psk: pskey) : (id * msg) * istate
  proc msg2(b: id, m1: id * msg, psk: pskey) : (msg * rstate) option
  proc msg3(a: id, s: istate, m2: msg) : (msg * key) option
  proc fin(b: id, s: rstate, m3: msg) : key option
}.


(********************************************************************************)
(* WAKE package and games *)

module type GWAKE_out = {
  (* Public key generation *)
  proc gen_pskey(a: id, b: id) : unit

  (* Active man-in-the-middle *)
  proc init(a: id, r : role, b:  id) : int * msg option
  proc send_msg2(j: int, m1: id * msg) : msg option
  proc send_msg3(i: int, m2: msg) : msg option
  proc send_fin(j: int, m3: msg) : unit option

  (* Get a session key *)
  proc rev_skey(i: int) : key option
  proc test(i: int) : key option
}.

module type GWAKE_out_i = {
  include GWAKE_out 

  proc init_mem() : unit
}.

module GWAKEb (P : AKE_Scheme) = {
  var state_map: (int, id * role * instance_state) fmap
  var psk_map: (id * id, pskey) fmap
  var cnt: int

  proc init_mem() : unit = {
    state_map <- empty;
    psk_map <- empty;
    cnt <- 0;
  }

  proc gen_pskey(a: id, b: id) : unit = {
    var k;
    if ((a, b) \notin psk_map) {
      k <$ dpskey;
      psk_map.[(a, b)] <- k;
    }
  }

  proc init(a: id, r:  role, b: id) : int * msg option = {
    var psk, st, m;
    var mo <- None;

    if ((a, b) \in psk_map) {
      cnt <- cnt + 1;
      if (r = Initiator) {
        psk <- oget psk_map.[(a, b)];
        (m, st) <@ P.msg1(a, b, psk);
        mo <- Some m.`2;
        state_map.[cnt] <- (a, Initiator, IPending st m);
      } else {
        state_map.[cnt] <- (a, Responder, RStarted b);
      }
    }
    return (cnt, mo);
  }


  proc send_msg2(j: int, m1: id * msg) : msg option = {
    var a, m2, s, resp, psk, role, b, st;
    var m <- None;

    a <- m1.`1;
    (b, role, st) <- oget state_map.[j];
    if (st = RStarted a) {
      psk <- oget psk_map.[(a, b)];
      resp <@ P.msg2(b, m1, psk);
      match resp with
      | None => state_map.[j] <- (b, Responder, Aborted);
      | Some val => {
        (m2, s) <- val;
        state_map.[j] <- (b, Responder, RPending s m1 m2);
        m <- Some m2;
      }
      end;
    }
    return m;
  }

  proc send_msg3(i: int, m2: msg) : msg option = {
    var m3, key, id, role, st, resp;
    var r <- None;

    if (i \in state_map) {
      (id, role, st) <- oget state_map.[i];
      if (st is IPending s m1) {
        resp <@ P.msg3(id, s, m2);
        match resp with
        | None => state_map.[i] <- (id, Initiator, Aborted);
        | Some val => {
          (m3, key) <- val;
          state_map.[i] <- (id, Initiator, Accepted (m1, m2, m3) key);
        }
        end;
      }
    }
    return r;
  }

  proc send_fin(j: int, m3: msg) : unit option = {
    var role, st, resp, id;
    var r <- None;

    if (j \in state_map) {
      (id, role, st) <- oget state_map.[j];
      if (st is RPending s m1 m2) {
        resp <@ P.fin(id, s, m3);
        match resp with
        | None => state_map.[j] <- (id, Responder, Aborted);
        | Some key => {
          state_map.[j] <- (id, Responder, Accepted (m1, m2, m3) key);
          r <- Some ();
        }
        end;
      }
    }
    return r;
  }

  proc rev_skey(i: int) : key option = {
    var id, role, st, p_id, p_role, p_st, ps, p, k;
    var ko <- None;

    if (i \in state_map) {
      (id, role, st) <- oget state_map.[i];
      match st with
      | Accepted trace k' => {
        k <- k';
        (* Get partners *)
        ps <- get_partners i (Some trace) role state_map;
        if (card ps <= 1) {
          ps <- get_observed_partners i state_map;
          (* If we have no observed partners then, we can test *)
          if (card ps <> 0) {
            (* If a partner has revealed something, we must use the same key *)
            p <- pick ps;
            (p_id, p_role, p_st) <- oget GWAKEb.state_map.[p];
            if (p_st is Observed _ p_k) {
              k <- p_k;
            }
          }
          ko <- Some k;
          state_map.[i] <- (id, role, Observed trace k);
        }
      }
      | Observed _ k'  => ko <- Some k';
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | RStarted _     => { }
      | Aborted        => { }
      end;
    }
    return ko;
  }
}.

module GWAKE0 (P : AKE_Scheme) : GWAKE_out_i = {
  include var GWAKEb(P)

  proc test = GWAKEb(P).rev_skey
}.

module GWAKE1 (P : AKE_Scheme) : GWAKE_out_i = {
  include var GWAKEb(P)

  proc test(i: int) : key option = {
    var id, role, st, p_id, p_role, p_st, ps, p, k;
    var ko <- None;

    if (i \in state_map) {
      (id, role, st) <- oget state_map.[i];
      match st with
      | Accepted trace k' => {
        k <$ dkey;
        (* Get partners *)
        ps <- get_partners i (Some trace) role state_map;
        if (card ps <= 1) {
          ps <- get_observed_partners i state_map;
          (* If we have no observed partners then, we can test *)
          if (card ps <> 0) {
            (* If a partner has revealed something, we must use the same key *)
            p <- pick ps;
            (p_id, p_role, p_st) <- oget GWAKEb.state_map.[p];
            if (p_st is Observed _ p_k) {
              k <- p_k;
            }
          }
          ko <- Some k;
          state_map.[i] <- (id, role, Observed trace k);
        }
      }
      | Observed _ k'  => ko <- Some k';
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | RStarted _     => { }
      | Aborted        => { }
      end;
    }
    return ko;
  }
}.


(********************************************************************************)
(* Adversary and Experiment *)

module type A_GWAKE (GW : GWAKE_out) = {
  proc run() : bool
}.

module E_GWAKE (O : GWAKE_out_i) (A : A_GWAKE) = {
  proc run() : bool = {
    var b : bool;

    O.init_mem();
    
    b <@ A(O).run();
    
    return b;
  }
}.
