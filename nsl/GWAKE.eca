require import AllCore FMap FSet.

type id, msg, istate, rstate, key, pskey.

op dkey: key distr.
op dpskey: pskey distr.

(* Represents the role of an instance in the protocol *)
type role = [
  Initiator
| Responder
].

type trace = (id * msg) * msg * msg.

(* Represents an instance state in the protocol *)
type instance_state = [
  RStarted of id
| IPending of istate & (id * msg)
| RPending of rstate & (id * msg) & msg
| Accepted of trace & key
| Observed of trace & key
| Aborted
].

(* Return the trace from an accepted state *)
op get_trace s : trace option =
with s = Accepted t _   => Some t
with s = Observed t _   => Some t
with s = IPending _ _   => None
with s = RPending _ _ _ => None
with s = RStarted _     => None
with s = Aborted        => None.

(* Decide if an instance has been revelaed *)
op is_observed s : bool =
with s = Observed _ _   => true
with s = Accepted _ _   => false
with s = IPending _ _   => false
with s = RPending _ _ _ => false
with s = RStarted _     => false
with s = Aborted        => false.

(* Get all trace-sharing instances *)
op get_ts_instances t (fmap : (int, id * role * instance_state) fmap) =
  fdom (filter (fun x (val: id * role * instance_state) => (get_trace val.`3) = Some t) fmap).

(* Get all partners of the given instance *)
op get_partners ai t r (fmap: (int, id * role * instance_state) fmap) =
fdom (
  filter
  (fun bj (val: id * role * instance_state) =>
        bj <> ai            (* We cannot be our own partner *)
    /\ get_trace val.`3 = t (* Partners share the same trace *)
    /\ val.`2 <> r          (* Partners must have opposite roles *)
    /\ t <> None            (* We must be accepted *)
  )
  fmap
).

op get_observed_partners ai  (fmap : (int, id * role * instance_state) fmap) =
  let (i, r, s) = oget fmap.[ai] in
  filter
    (fun bj => oapp (fun z => is_observed z) false (Some (oget fmap.[bj]).`3))
    (get_partners ai (get_trace s) r fmap).

(********************************************************************************)
(* Defining AKE schemes *)

module type AKE_Scheme = {
  proc msg1(a: id, b: id, psk: pskey) : msg * istate
  proc msg2(b: id, m1: id * msg, psk: pskey) : (msg * rstate) option
  proc msg3(a: id, s: istate, m2: msg) : (msg * key) option
  proc fin(b: id, s: rstate, m3: msg) : key option
}.


(********************************************************************************)
(* WAKE package and games *)

module type GWAKE_out = {
  (* Public key generation *)
  proc gen_pskey(a: id, b: id) : unit

  (* Active man-in-the-middle *)
  proc init(a: id, r : role, b:  id) : int * msg option
  proc send_msg2(j: int, m1: id * msg) : msg option
  proc send_msg3(i: int, m2: msg) : msg option
  proc send_fin(j: int, m3: msg) : unit option

  (* Get a session key *)
  proc rev_skey(i: int) : key option
  proc test(i: int) : key option
  proc is_partnered (i: int, j: int) : bool
}.

module type GWAKE_out_i = {
  include GWAKE_out 

  proc init_mem() : unit
}.


module GWAKEb (W : AKE_Scheme) = {
  var state_map: (int, id * role * instance_state) fmap
  var psk_map: (id * id, pskey) fmap
  var cnt: int

  proc init_mem() : unit = {
    state_map <- empty;
    psk_map <- empty;
    cnt <- 0;
  }

  proc gen_pskey(a: id, b: id) : unit = {
    var k;
    if ((a, b) \notin psk_map) {
      k <$ dpskey;
      psk_map.[(a, b)] <- k;
    }
  }

  proc init(a: id, r:  role, b: id) : int * msg option = {
    var psk, st, m;
    var mo <- None;

    if ((a, b) \in psk_map) {
      cnt <- cnt + 1;
      if (r = Initiator) {
        psk <- oget psk_map.[(a, b)];
        (m, st) <@ W.msg1(a, b, psk);
        mo <- Some m;
        state_map.[cnt] <- (a, Initiator, IPending st (b, m));
      } else {
        state_map.[cnt] <- (a, Responder, RStarted b);
      }
    }
    return (cnt, mo);
  }


  proc send_msg2(j: int, m1: id * msg) : msg option = {
    var a, m2, s, resp, psk, role, b, inst_s;
    var m <- None;

    a <- m1.`1;
    (b, role, inst_s) <- oget state_map.[j];
    if (role = Responder /\ inst_s = RStarted a /\ (a, b) \in psk_map) {
      psk <- oget psk_map.[(a, b)];
      resp <@ W.msg2(b, m1, psk);
      match resp with
      | None => state_map.[j] <- (b, Responder, Aborted);
      | Some val => {
        (m2, s) <- val;
        state_map.[j] <- (b, Responder, RPending s m1 m2);
        m <- Some m2;
      }
      end;
    }
    return m;
  }

  proc send_msg3(i: int, m2: msg) : msg option = {
    var m3, key, id, role, inst_s, resp;
    var r <- None;

    if (i \in state_map) {
      (id, role, inst_s) <- oget state_map.[i];
      if (role = Initiator) {
        if (inst_s is IPending s m1) {
          resp <@ W.msg3(id, s, m2);
          match resp with
          | None => state_map.[i] <- (id, Initiator, Aborted);
          | Some val => {
            (m3, key) <- val;
            if (card (get_ts_instances (m1, m2, m3) state_map) = 0) {
              state_map.[i] <- (id, Initiator, Accepted (m1, m2, m3) key);
              r <- Some m3;
            } else {
              state_map.[i] <- (id, Initiator, Aborted);
            }
          }
          end;
        }
      }
    }
    return r;
  }

  proc send_fin(j: int, m3: msg) : unit option = {
    var role, inst_s, resp, id;
    var r <- None;

    if (j \in state_map) {
      (id, role, inst_s) <- oget state_map.[j];
      if (role = Responder) {
        if (inst_s is RPending s m1 m2) {
          resp <@ W.fin(id, s, m3);
          match resp with
          | None => state_map.[j] <- (id, Responder, Aborted);
          | Some key => {
            if (card (get_ts_instances (m1, m2, m3) state_map) = 1) {
              state_map.[j] <- (id, Responder, Accepted (m1, m2, m3) key);
              r <- Some ();
            } else {
              state_map.[j] <- (id, Responder, Aborted);
            }
          }
          end;
        }
      }
    }
    return r;
  }

  proc rev_skey(i: int) : key option = {
    var id, role, inst_s, p_id, p_role, p_inst_s, ps, p, rev_ps;
    var k <- None;

    if (i \in state_map) {
      (id, role, inst_s) <- oget state_map.[i];
      match inst_s with
      | Accepted t k' => {
        k <- Some k';
        (* Get partners *)
        ps <- get_partners i (get_trace (oget state_map.[i]).`3) ((oget state_map.[i]).`2) state_map;
        rev_ps <- get_observed_partners i state_map;

        (* If we have no observed partners then, we can test *)
        if (card ps <= 1 /\ card rev_ps = 0) {
          state_map.[i] <- (id, role, Observed t k');
        } else {
          (* If a partner has revealed something, we must use the same key *)
          p <- pick rev_ps;
          (p_id, p_role, p_inst_s) <- oget state_map.[p];
          if (p_inst_s is Observed _ kr) {
            k <- Some kr;
            state_map.[i] <- (id, role, Observed t kr);
          }
        }
      }
      | Observed _ k'  => k <- Some k';
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | RStarted _     => { }
      | Aborted        => { }
      end;
    }
    return k;
  }

  proc is_partnered(i: int, j: int) : bool = {
    var ps;
    var b <- false;

    ps <- get_partners i (get_trace (oget state_map.[i]).`3) ((oget state_map.[i]).`2) state_map;
    if (j \in ps /\ card ps = 1) {
      b <- true;
    }
    return b;
  }
}.

module GWAKE0 (W : AKE_Scheme) : GWAKE_out_i = {
  include GWAKEb(W)

  proc test = GWAKEb(W).rev_skey
}.

module GWAKE1 (W : AKE_Scheme) : GWAKE_out_i = {
  include GWAKEb(W)

  proc test (i: int) : key option = {
    var id, role, inst_s, p_id, p_role, p_inst_s, ps, p, rev_ps, k;
    var ko <- None;

    if (i \in GWAKEb.state_map) {
      (id, role, inst_s) <- oget GWAKEb.state_map.[i];
      match inst_s with
      | Accepted t k' => {
        k <$ dkey;
        (* Get partners *)
        ps <- get_partners i (get_trace (oget GWAKEb.state_map.[i]).`3) ((oget GWAKEb.state_map.[i]).`2) GWAKEb.state_map;
        rev_ps <- get_observed_partners i GWAKEb.state_map;

        (* If we have no observed partners then, we can test *)
        if (!(card ps <= 1 /\ card rev_ps = 0)) {
          (* If a partner has revealed something, we must use the same key *)
          p <- pick rev_ps;
          (p_id, p_role, p_inst_s) <- oget GWAKEb.state_map.[p];
          if (p_inst_s is Observed _ kr) {
            k <- kr;
          }
        }
        ko <- Some k;
        GWAKEb.state_map.[i] <- (id, role, Observed t k);
      }
      | Observed _ k'  => ko <- Some k';
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | RStarted _     => { }
      | Aborted        => { }
      end;
    }
    return ko;
  }
}.


(********************************************************************************)
(* Adversary and Experiment *)

module type A_GWAKE (GW : GWAKE_out) = {
  proc run() : bool
}.

module E_GWAKE (O : GWAKE_out_i) (A : A_GWAKE) = {
  proc run() : bool = {
    var b : bool;

    O.init_mem();
    
    b <@ A(O).run();
    
    return b;
  }
}.
