require import AllCore FMap FSet.

(********************************************************************************)
(* Defining the base types and operators for AKE *)

type id, msg, istate, rstate, key, pskey.

op dkey: key distr.
op dpskey: pskey distr.

(* Represents the role of an instance in the protocol *)
type role = [
  Initiator
| Responder
].

(* Trace of sent/received messages for a session *)
type trace = (id * msg) * msg * msg.

(* Represents an session state in the protocol *)
type session_state = [
| IPending of istate & (id * msg)
| RPending of rstate & (id * msg) & msg
| Accepted of trace & key
| Observed of trace & key
| Aborted
].

(* Return the trace from an accepted state *)
op trace s : trace option =
with s = Accepted t _   => Some t
with s = Observed t _   => Some t
with s = IPending _ _   => None
with s = RPending _ _ _ => None
with s = Aborted        => None.

(* Decide if an instance has been revelaed *)
op observed s : bool =
with s = Observed _ _   => true
with s = Accepted _ _   => false
with s = IPending _ _   => false
with s = RPending _ _ _ => false
with s = Aborted        => false.

(* Compute the partners of a given session *)
op partners h (sm: (id * int, role * session_state) fmap) =
fdom (
  filter
  (fun h' (s: _ * _) =>
       trace (oget sm.[h]).`2 <> None      (* Partners must be accepted *)
    /\ trace (oget sm.[h]).`2 = trace s.`2 (* Partners must share the same trace *)
    /\ (oget sm.[h]).`1 <> s.`1            (* Partners must have opposite roles *)
  )
  sm
).

(* Compute the observed partners of a given session *)
op observed_partners h (sm : (id * int, role * session_state) fmap) =
  filter
    (fun h' => oapp (observed \o snd) false sm.[h'])
    (partners h sm).

(* Check freshness of a given session *)
op fresh h sm =
     card (partners h sm) <= 1         (* Fresh sessions have no more than one partner *)
  /\ card (observed_partners h sm) = 0 (* Fresh sessions have no observed partners *)
.

(********************************************************************************)
(* Defining AKE schemes *)

module type AKE_Scheme = {
  proc msg1(a: id, b: id, psk: pskey) : (id * msg) * istate
  proc msg2(b: id, m1: id * msg, psk: pskey) : (msg * rstate) option
  proc msg3(a: id, s: istate, m2: msg) : (msg * key) option
  proc fin(b: id, s: rstate, m3: msg) : key option
}.


(********************************************************************************)
(* AKE Oracles *)

module type AKE_Oracles = {
  (* Public key generation *)
  proc gen_pskey(_: id * id) : unit

  (* Active man-in-the-middle *)
  proc send_msg1(_: id * int * id) : msg option
  proc send_msg2(_: id * int * (id * msg)) : msg option
  proc send_msg3(_: id * int * msg) : msg option
  proc send_fin(_: id * int * msg) : unit option

  (* Get a session key *)
  proc reveal(_: id * int) : key option
  proc test(_: id * int) : key option
}.

module type AKE_Oracles_i = {
  include AKE_Oracles
  proc init_mem(b: bool) : unit
}.

module AKE_Oracles (P : AKE_Scheme) : AKE_Oracles_i = {
  var b0 : bool

  var state_map: (id * int, role * session_state) fmap
  var psk_map: (id * id, pskey) fmap

  proc init_mem(b) = {
    b0 <- b;
    state_map <- empty;
    psk_map <- empty;
  }

  proc gen_pskey(a, b) = {
    var k;

    if ((a, b) \notin psk_map) {
      k <$ dpskey;
      psk_map.[(a, b)] <- k;
    }
  }

  proc send_msg1(a, i, b) = {
    var m1, si;
    var mo <- None;

    if ((a, i) \notin state_map /\ (a, b) \in psk_map) {
      (m1, si) <@ P.msg1(a, b, oget psk_map.[a, b]);
      state_map.[a, i] <- (Initiator, IPending si m1);
      mo <- Some m1.`2;
    }
    return mo;
  }

  proc send_msg2(b, j, m1) = {
    var a, ca, resp, m2, s; 
    var mo <- None;

    (a, ca) <- m1;
    if ((b, j) \notin state_map /\ (a, b) \in psk_map) {
      resp <@ P.msg2(b, m1, oget psk_map.[a, b]);
      match resp with
      | None => state_map.[b, j] <- (Responder, Aborted);
      | Some v => {
        (m2, s) <- v;
        state_map.[b, j] <- (Responder, RPending s m1 m2);
        mo <- Some m2;
      }
      end;
    }
    return mo;
  }

  proc send_msg3(a, i, m2) = {
    var r, s, resp, m3, k;
    var mo <- None;

    if ((a, i) \in state_map) {
      (r, s) <- oget state_map.[a, i];
      if (s is IPending si m1) {
        resp <@ P.msg3(a, si, m2);
        match resp with
        | None => state_map.[a, i] <- (Initiator, Aborted);
        | Some v => {
          (m3, k) <- v;
          state_map.[a, i] <- (Initiator, Accepted (m1, m2, m3) k);
          mo <- Some m3;
        }
        end;
      }
    }
    return mo;
  }

  proc send_fin(b, j, m3) = {
    var r, s, resp;
    var mo <- None;

    if ((b, j) \in state_map) {
      (r, s) <- oget state_map.[b, j];
      if (s is RPending sr m1 m2) {
        resp <@ P.fin(b, sr, m3);
        match resp with
        | None => state_map.[b, j] <- (Responder, Aborted);
        | Some k => {
          state_map.[b, j] <- (Responder, Accepted (m1, m2, m3) k);
          mo <- Some ();
        }
        end;
      }
    }
    return mo;
  }

  proc reveal(h) = {
    var r, s;
    var ko <- None;

    if (h \in state_map) {
      (r, s) <- oget state_map.[h];
      match s with
      | Accepted t k => {
        if (fresh h state_map) {
          state_map.[h] <- (r, Observed t k);
          ko <- Some k;
        }
      }
      | Observed _ _   => { }
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | Aborted        => { }
      end;
    }
    return ko;
  }

  proc test(h) = {
    var r, s, k';
    var ko <- None;

    if (h \in state_map) {
      (r, s) <- oget state_map.[h];
      match s with
      | Accepted t k => {
        if (fresh h state_map) {
          if (b0 = false) {
            k' <- k;
          } else {
            k' <$ dkey;
          }
          state_map.[h] <- (r, Observed t k');
          ko <- Some k';
        }
      }
      | Observed _ _   => { }
      | IPending _ _   => { }
      | RPending _ _ _ => { }
      | Aborted        => { }
      end;
    }
    return ko;
  }
}.


(********************************************************************************)
(* Adversary and Game *)

module type AKE_Adversary (O : AKE_Oracles) = {
  proc run() : bool
}.

module AKE_Game (O : AKE_Oracles_i) (A : AKE_Adversary) = {
  proc run(b: bool) : bool = {
    var b' : bool;

    O.init_mem(b);
    b' <@ A(O).run();

    return b';
  }
}.
