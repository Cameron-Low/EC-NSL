require import Distr FMap.

(********************************************************************************)
(* AEAD base type and operator definitions *)

type key, data, ctxt, ptxt.
type handle.
type d_in_t.

op dkey : key distr.
op dctxt : ctxt distr.

op enc : key -> data -> ptxt -> ctxt distr.
op dec : key -> data -> ctxt -> ptxt option.

axiom correctness k ad p c:
   k \in dkey
=> c \in enc k ad p
=> dec k ad c = Some p.

(********************************************************************************)
(* AEAD Oracle definitions *)

module type AEAD_Oracles = {
  proc gen(_: handle) : unit
  proc ex(_: handle) : bool
  proc enc(_: handle * data * ptxt) : ctxt option
  proc dec(_: handle * data * ctxt) : ptxt option
}.

module type AEAD_Oracles_i = {
  include AEAD_Oracles
  proc init_mem() : unit
}.

module AEAD_Oracles_common = {
  var key_map : (handle, key) fmap

  proc gen(h: handle) : unit = {
    var k;
    if (h \notin key_map) {
      k <$ dkey;
      key_map.[h] <- k;
    }
  }

  proc ex(h: handle) : bool = {
    return h \in key_map;
  }
}.

module AEAD_Oracles_0 : AEAD_Oracles_i = {
  include var AEAD_Oracles_common

  proc init_mem() = {
    key_map <- empty;
  }

  proc enc(h: handle, ad: data, p: ptxt) : ctxt option = {
    var c;
    var r <- None;

    if (key_map.[h] is Some k) {
      c <$ enc k ad p;
      r <- Some c;
    }
    return r;
  }

  proc dec(h: handle, ad: data, c: ctxt) : ptxt option = {
    var p <- None;

    if (key_map.[h] is Some k) {
      p <- dec k ad c;
    }
    return p;
  }
}.

module AEAD_Oracles_1 : AEAD_Oracles_i = {
  include var AEAD_Oracles_common
  var dec_map : (handle * data * ctxt, ptxt) fmap

  proc init_mem() = {
    key_map <- empty;
    dec_map <- empty;
  }

  proc enc(h: handle, ad: data, p : ptxt) : ctxt option = {
    var c;
    var r <- None;

    if (h \in key_map) {
      c <$ dctxt;
      dec_map.[h, ad, c] <- p;
      r <- Some c;
    }
    return r;
  }

  proc dec(h: handle, ad: data, c: ctxt) : ptxt option = {
    var p <- None;

    if (h \in key_map) {
      p <- dec_map.[h, ad, c];
    }
    return p;
  }
}.


(********************************************************************************)
(* Adversary and Game *)
module type AEAD_Adversary (O : AEAD_Oracles) = {
  proc run(_: d_in_t) : bool
}.

module AEAD_Game (O : AEAD_Oracles_i) (A : AEAD_Adversary) = {
  proc run(x : d_in_t) : bool = {
    var b : bool;

    O.init_mem();
    b <@ A(O).run(x);

    return b;
  }
}.
