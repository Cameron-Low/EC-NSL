require import FMap.

(********************************************************************************)
(* PRF base type and operator definitions *)

type handle, key, D, R, d_in_t.

op dkey : key distr.
op dR : D -> R distr.

op f : key -> D -> R.

(********************************************************************************)
(* PRF Oracle definitions *)

module type PRF_Oracles = {
  proc gen(_: handle) : unit
  proc f(_: handle * D) : R option
}.

module type PRF_Oracles_i = {
  include PRF_Oracles
  proc init_mem() : unit
}.

module PRF_Oracles_common = {
  var key_map : (handle, key) fmap

  proc gen(h) : unit = {
    var k;

    if (h \notin key_map) {
      k <$ dkey;
      key_map.[h] <- k;
    }
  }
}.

module PRF_Oracles_0 : PRF_Oracles_i = {
  include var PRF_Oracles_common

  proc init_mem() = {
    key_map <- empty;
  }

  proc f(h, x) = {
    var r <- None;
    if (key_map.[h] is Some k) {
      r <- Some (f k x);
    }
    return r;
  }
}.

module PRF_Oracles_1 : PRF_Oracles_i = {
  include var PRF_Oracles_common

  var cache : (handle * D, R) fmap

  proc init_mem() = {
    key_map <- empty;
    cache <- empty;
  }

  proc f(h, x) = {
    var y;
    var r <- None;
    if (key_map.[h] is Some k) {
      y <$ dR x;
      if ((h, x) \notin cache) {
        cache.[(h, x)] <- y;
      }
      r <- cache.[(h, x)];
    }
    return r;
  }
}.

(********************************************************************************)
(* Adversary and Experiment *)

module type PRF_Adversary (O : PRF_Oracles) = {
  proc run(_: d_in_t) : bool
}.

module PRF_Game (O : PRF_Oracles_i) (A : PRF_Adversary) = {
  proc run(x) : bool = {
    var b : bool;

    O.init_mem();
    b <@ A(O).run(x);

    return b;
  }
}.
